name: macOS

on:
  workflow_dispatch:
  pull_request:
  push:
    branches: [ "develop", "master" ]
  schedule:
    - cron: '00 21 * * *'

concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

jobs:
  general:
    strategy:
      fail-fast: false
      matrix:
        # https://docs.github.com/en/actions/using-github-hosted-runners/using-github-hosted-runners/about-github-hosted-runners
        # 13 - X86_64
        # 14 or latest - Arm64 M1
        version: [13, 14]
        build-tool: [ autotools, cmake ]
        compiler: [ {cpp: clang++, c: clang}, {cpp: g++, c: gcc} ]
        macports-version: [2.10.1]
        exclude:
          # NOTE: This can be excluded to speed up the testing matrix, as clang is the default compiler on macOS
          #       and it is used for development too on an everyday basis, on arm64.
          - version: 14
            compiler: {cpp: clang++, c: clang}

    runs-on: macOS-${{ matrix.version }}
    name: macOS${{ matrix.version }}-${{ matrix.version == '14' && 'arm64' || 'amd64' }}, ${{ matrix.build-tool }}, ${{ matrix.compiler.c }}
    env:
      MACPORTS_ARCHIVE_DIR: $HOME/macports-cache
      MACPORTS_ARCHIVE_FILE: $HOME/macports-cache/macports.tzst
      MACPORTS_USER_INFO_FILE: $HOME/macports-cache/macports-user-info.txt

    steps:
      - name: Checkout syslog-ng source
        uses: actions/checkout@v4

      - name: Set xcode version
        if: matrix.version == 14
        run: |
          sudo xcode-select -s /Applications/Xcode_15.2.app

      - name: Unlinking preinstalled Python (workaround)
              # The python@3 brew package has to be installed and linked system-wide (it's a dependency of glib and syslog-ng)
              # The macos-13 GitHub runner has Python preinstalled as a pkg, this prevents linking the python@3
              # brew package, even when linking is forced. `brew "python@3", link: true, force: true`
              # also, brew cannot update the links even these cretated by itself for an earlier python version
        run: |
          find /usr/local/bin/ -lname "*Python.framework*" -delete

      # Compose cache keys dynamically
      - name: Compose cache keys
        run: |
          echo "HOMEBREW_CACHE_KEY=${{ runner.os }}${{ matrix.version }}-homebrew-${{ runner.arch }}-${{ hashFiles('contrib/Brewfile') }}" >> $GITHUB_ENV
          echo "HOMEBREW_CACHE_RESTORE_KEY=${{ runner.os }}${{ matrix.version }}-homebrew-${{ runner.arch }}-" >> $GITHUB_ENV
          echo "MACPORTS_CACHE_KEY=${{ runner.os }}${{ matrix.version }}-macports-${{ runner.arch }}-${{ matrix.macports-version }}" >> $GITHUB_ENV
          echo "MACPORTS_CACHE_RESTORE_KEY=${{ runner.os }}${{ matrix.version }}-macports-${{ runner.arch }}-" >> $GITHUB_ENV
          echo "MACPORTS_USER_INFO_CACHE_KEY=${{ runner.os }}${{ matrix.version }}-macports-user-info-${{ runner.arch }}-${{ matrix.macports-version }}" >> $GITHUB_ENV

      # -------------------------------
      # Restore Homebrew dependencies from cache
      # The cache update is automatic as a "Post" step at the job end
      - name: Cache Homebrew dependencies
        uses: actions/cache@v3
        with:
          path: /Users/runner/Library/Caches/Homebrew
          key: ${{ env.HOMEBREW_CACHE_KEY }}
          restore-keys: ${{ env.HOMEBREW_CACHE_RESTORE_KEY }}

      # -------------------------------
      # Install Homebrew dependencies
      # TODO: We can add caching of the whole /usr/local/Homebrew folder too and use that cache in none scheduled runs.
      #       During the scheduled runs we can update the cache after a full brew update --auto-update.
      #       One drawback is the size of the cache image that is ~4GB (not compressed) with the current Brewfile package list.
      - name: Install Homebrew dependencies
        run: |
          if [ "${{ runner.arch }}" = "ARM64" ] || [ "${{ github.event_name }}" = "schedule" ]; then
            if [ "${{ github.event_name }}" = "schedule" ]; then
              echo "Scheduled run → forcing brew update"
            fi
            # temp: to avoid openssl@1.1 and openssl@3 conflicts on some runners
            brew unlink openssl@1.1 || true
            brew unlink openssl@3 || true
            rm -f /opt/homebrew/bin/openssl
            rm -f /Users/runner/Library/Caches/Homebrew/Backup/bin/openssl

            brew update --auto-update
          else
            echo "Non-scheduled run → skipping brew update"
            export HOMEBREW_NO_AUTO_UPDATE=1
            export HOMEBREW_NO_INSTALL_CLEANUP=1
          fi
          brew bundle --force --file=contrib/Brewfile

      # -------------------------------
      # Restore MacPorts user/group info from separate cache
      # The cache update is automatic as a "Post" step at the job end
      - name: Cache MacPorts user/group info
        id: macports-user-info-restore
        uses: actions/cache@v3
        with:
          path: ${{ env.MACPORTS_USER_INFO_FILE }}
          key: ${{ env.MACPORTS_USER_INFO_CACHE_KEY }}

      # -------------------------------
      # Restore MacPorts self-made archive from cache (if available)
      # NOTE: We cannot use the built-in restore, as that can not work as root; we handle extraction manually
      - name: Cache MacPorts archive
        uses: actions/cache@v3
        with:
          path: ${{ env.MACPORTS_ARCHIVE_FILE }}
          key: ${{ env.MACPORTS_CACHE_KEY }}
          restore-keys: ${{ env.MACPORTS_CACHE_RESTORE_KEY }}

      # -------------------------------
      # Install MacPorts dependencies
      - name: Install/Update MacPorts dependencies
        run: |
          mkdir -p "$MACPORTS_ARCHIVE_DIR"

          if [ -f "$MACPORTS_ARCHIVE_FILE" ]; then
            echo "Restoring MacPorts from cached archive..."
            sudo tar -C / -xf "$MACPORTS_ARCHIVE_FILE"

            # Ensure macports user and group exist
            CURRENT_MACPORTS_UID=$(id -u macports 2>/dev/null || echo "")
            CURRENT_MACPORTS_GID=$(id -g macports 2>/dev/null || echo "")

            if [ -n "$CURRENT_MACPORTS_UID" ] && [ -n "$CURRENT_MACPORTS_GID" ]; then
              echo "macports user(${CURRENT_MACPORTS_UID}) and group(${CURRENT_MACPORTS_GID}) already exist."
            else
              echo "Creating macports user and group..."
              if [ -f "$MACPORTS_USER_INFO_FILE" ]; then
                source "$MACPORTS_USER_INFO_FILE"
                echo "Using saved macports user(${MACPORTS_UID}) and group(${MACPORTS_GID}) IDs."
              else
                # Pick next free IDs dynamically
                MACPORTS_UID=$(dscl . -list /Users UniqueID | awk '{print $2}' | sort -n | tail -1 | awk '{print $1+1}')
                MACPORTS_GID=$(dscl . -list /Groups PrimaryGroupID | awk '{print $2}' | sort -n | tail -1 | awk '{print $1+1}')
                echo "Collected next free macports user(${MACPORTS_UID}) and group(${MACPORTS_GID}) IDs."
              fi

              sudo dscl . -create /Groups/macports
              sudo dscl . -create /Groups/macports PrimaryGroupID $MACPORTS_GID
              sudo dscl . -create /Users/macports
              sudo dscl . -create /Users/macports UniqueID $MACPORTS_UID
              sudo dscl . -create /Users/macports PrimaryGroupID $MACPORTS_GID
              sudo dscl . -create /Users/macports UserShell /usr/bin/false
              sudo dscl . -create /Users/macports NFSHomeDirectory /opt/local/var/macports/home
            fi

            # Fix ownership of extracted files
            echo "Fixing ownership of /opt/local..."
            sudo chown -R macports:macports /opt/local
          else
            echo "Cache missing — installing MacPorts..."
            OS_NAME=$([[ ${{ matrix.version }} -eq 13 ]] && echo "Ventura" || echo "Sonoma")
            MACPORTS_PKG_NAME=MacPorts-${{ matrix.macports-version }}-${{ matrix.version }}-${OS_NAME}.pkg
            MACPORTS_URL=https://github.com/macports/macports-base/releases/download/v${{ matrix.macports-version }}/${MACPORTS_PKG_NAME}

            wget "$MACPORTS_URL" -O "$MACPORTS_ARCHIVE_DIR/$MACPORTS_PKG_NAME"
            sudo installer -pkg "$MACPORTS_ARCHIVE_DIR/$MACPORTS_PKG_NAME" -target /
          fi

          # Save current macports user/group info
          CURRENT_MACPORTS_UID=$(id -u macports)
          CURRENT_MACPORTS_GID=$(id -g macports)
          echo "Saving macports user(${CURRENT_MACPORTS_UID})/group(${CURRENT_MACPORTS_GID}) info..."
          mkdir -p $(dirname "${MACPORTS_USER_INFO_FILE}")
          echo "MACPORTS_UID=$CURRENT_MACPORTS_UID" > "${MACPORTS_USER_INFO_FILE}"
          echo "MACPORTS_GID=$CURRENT_MACPORTS_GID" >> "${MACPORTS_USER_INFO_FILE}"

          # Ensure MacPorts and ports are up-to-date
          sudo /opt/local/bin/port -v selfupdate
          sudo /opt/local/bin/port upgrade outdated
          sudo /opt/local/bin/port install libesmtp

          # Create/update the archive for caching
          sudo rm -f "$MACPORTS_ARCHIVE_FILE"
          echo "Creating/updating MacPorts archive..."
          sudo tar -C / -cf "$MACPORTS_ARCHIVE_FILE" /opt/local
          sudo chown $USER:staff "$MACPORTS_ARCHIVE_FILE"

      - name: Set ENV variables
        env:
          CC: ${{ matrix.compiler.c }}
          CXX: ${{ matrix.compiler.cpp }}

        run: |
          . .github/workflows/gh-tools.sh

          HOMEBREW_PREFIX="$(brew --prefix)"
          MACPORTS_PREFIX=/opt/local
          SYSLOG_NG_INSTALL_DIR="${HOME}/install/syslog-ng"
          PYTHONUSERBASE="${HOME}/python_packages"
          THREADS="$(sysctl -n hw.physicalcpu)"
          WARNING_FLAGS="-Wno-unused-command-line-argument" # FIXME: -Werror must be re-added
          CFLAGS="-I${HOMEBREW_PREFIX}/include/ -I${MACPORTS_PREFIX}/include ${WARNING_FLAGS}"
          CXXFLAGS="${CFLAGS}"
          # brew has an old autoconf-archive -> ax_cxx_compile_stdcxx.m4 version, which cannot detect
          # correctly the c++14 and c++17 support of clang currently, get the latest one from the git repo
          if [ ${{ matrix.build-tool }} = autotools ] && [ $CC = clang ]; then
            mkdir -p ./m4 || true
            wget -O ./m4/ax_cxx_compile_stdcxx.m4 https://raw.githubusercontent.com/autoconf-archive/autoconf-archive/master/m4/ax_cxx_compile_stdcxx.m4
          fi
          LDFLAGS="-L${HOMEBREW_PREFIX}/lib -L${MACPORTS_PREFIX}/lib"
          CONFIGURE_FLAGS="
            `[ $CC = clang ] && echo '--enable-force-gnu99' || true`
            --enable-colored-log
            --enable-extra-warnings
            --enable-debug
            --prefix=${SYSLOG_NG_INSTALL_DIR}
            --enable-tests
            --enable-all-modules
            --with-python=3
            --with-ivykis=internal
            --with-systemd-journal=no
            --disable-java
            --disable-java-modules
          "
          CMAKE_CONFIGURE_FLAGS="
            `[ $CC = clang ] && echo '-DENABLE_FORCE_GNU99=ON' || true`
            -DENABLE_EXTRA_WARNINGS=ON
            -DSUMMARY_LEVEL=1
            -DCMAKE_BUILD_TYPE=Debug
            -DCMAKE_INSTALL_PREFIX=${SYSLOG_NG_INSTALL_DIR}
            -DBUILD_TESTING=ON
            -DPYTHON_VERSION=3
            -DIVYKIS_SOURCE=internal
            -DENABLE_JOURNALD=OFF
            -DENABLE_JAVA=OFF
            -DENABLE_JAVA_MODULES=OFF
          "
          PKG_CONFIG_PATH="${HOMEBREW_PREFIX}/opt/openssl@3/lib/pkgconfig:${HOMEBREW_PREFIX}/opt/net-snmp/lib/pkgconfig:${HOMEBREW_PREFIX}/lib/pkgconfig:${MACPORTS_PREFIX}/lib/pkgconfig:${PKG_CONFIG_PATH}"
          PATH="${HOMEBREW_PREFIX}/opt/bison/bin:${HOMEBREW_PREFIX}/opt/libnet/bin:${HOMEBREW_PREFIX}/opt/net-snmp/bin:${HOMEBREW_PREFIX}/bin:${HOMEBREW_PREFIX}/sbin:${PYTHONUSERBASE}/bin:${MACPORTS_PREFIX}/bin:${MACPORTS_PREFIX}/sbin:${PATH}"

          gh_export HOMEBREW_PREFIX MACPORTS_PREFIX SYSLOG_NG_INSTALL_DIR PYTHONUSERBASE CC CXX PKG_CONFIG_PATH THREADS CONFIGURE_FLAGS CFLAGS CXXFLAGS LDFLAGS CMAKE_CONFIGURE_FLAGS PATH
          gh_path "${PATH}"

          env | sort
          #cat "${GITHUB_ENV}" | sort

      - name: Set gcc and g++ symlinks
        run: |
          if [ $CC = gcc ]; then
            ln -s "${HOMEBREW_PREFIX}/bin/gcc-14" "${HOMEBREW_PREFIX}/bin/gcc"
            ln -s "${HOMEBREW_PREFIX}/bin/g++-14" "${HOMEBREW_PREFIX}/bin/g++"
          fi

          echo "ARCH: " $(arch)
          echo "xcode:" $(xcode-select -p)
          echo "gcc:" $(which gcc; gcc --version)
          echo "g++:" $(which g++; g++ --version)
          echo "clang:" $(which clang; clang --version)

      - name: autogen.sh
        if: matrix.build-tool == 'autotools'
        run: |
          ./autogen.sh

      - name: autotools configure
        if: matrix.build-tool == 'autotools'
        run: |
          # Exclude of failing linking against GRPC dependencies when compiling with g++
          # g++ uses libstdc++, while grpc is compiled with libc++ on macOS, so the linking fails
          # with undefined symbols.
          # The proper solution is to compile grpc from source with g++, but that is way too long
          # and complicated for a CI job.
          if [ $CXX = g++ ]; then
            CONFIGURE_FLAGS="${CONFIGURE_FLAGS} --disable-grpc"
          fi
          ./configure ${CONFIGURE_FLAGS}

      - name: cmake configure
        if: matrix.build-tool == 'cmake'
        run: |
          # Exclude of failing linking against GRPC dependencies when compiling with g++
          # g++ uses libstdc++, while grpc is compiled with libc++ on macOS, so the linking fails
          # with undefined symbols.
          # The proper solution is to compile grpc from source with g++, but that is way too long
          # and complicated for a CI job.
          if [ $CXX = g++ ]; then
            CMAKE_CONFIGURE_FLAGS="${CMAKE_CONFIGURE_FLAGS} -DENABLE_GRPC=OFF"
          fi
          cmake --install-prefix "${SYSLOG_NG_INSTALL_DIR}" -B build . ${CMAKE_CONFIGURE_FLAGS}

      - name: cmake install
        if: matrix.build-tool == 'cmake'
        run: |
          set -e

          cmake --build ./build -j ${THREADS} --target install

          echo ""
          echo "Checking produced installation..."
          "${SYSLOG_NG_INSTALL_DIR}/sbin/syslog-ng" -FdevtV > syslog-ng.unsorted.log 2>&1
          sort syslog-ng.unsorted.log > syslog-ng.log

          cat syslog-ng.log
          # Check for failing modules
          if grep -q "Error opening plugin module;" syslog-ng.log; then
            echo "Modules failing to load:"
            grep "Error opening plugin module;" syslog-ng.log
            exit 1
          fi

      - name: cmake check
        # FIXME: Some of our checks still do not run correctly on silicon yet (and probably never will)
        if: matrix.build-tool == 'cmake' && matrix.version != 14
        run: |
          cmake --build ./build -j ${THREADS} --target check

      - name: make install
        if: matrix.build-tool == 'autotools'
        run: |
          set -e

          make --keep-going install -j ${THREADS} || \
            { \
              S=$?; \
              make V=1; \
              return $S; \
            }

          echo ""
          echo "Checking produced installation..."
          "${SYSLOG_NG_INSTALL_DIR}/sbin/syslog-ng" -FdevtV > syslog-ng.unsorted.log 2>&1
          sort syslog-ng.unsorted.log > syslog-ng.log

          cat syslog-ng.log
          # Check for failing modules
          if grep -q "Error opening plugin module;" syslog-ng.log; then
            echo "Modules failing to load:"
            grep "Error opening plugin module;" syslog-ng.log
            exit 1
          fi

      - name: make check
        # FIXME: Some of our checks still do not run correctly on silicon yet (and probably never will)
        if: matrix.build-tool == 'autotools' && matrix.version != 14
        run: |
          set -e

          make --keep-going check -j ${THREADS} || \
            { \
              S=$?; \
              echo "Output of first test invocation:"; \
              find . -name test-suite.log | xargs cat; \
              make V=1 check; \
              echo "Output of second test invocation:"; \
              find . -name test-suite.log | xargs cat; \
              return $S; \
            }
